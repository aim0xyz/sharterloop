<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Shatterloop - Aether Drifter</title>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  
  <style>
    * {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  touch-action: manipulation;
  /* Add these lines to prevent selection */
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
}
    
    body {
      font-family: 'Segoe UI', 'Helvetica Neue', sans-serif;
      background: linear-gradient(135deg, #0c0c2d, #000);
      color: white;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
		
    #gameContainer {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  max-width: 100vw;
  max-height: 100vh;
  overflow: hidden;
  touch-action: none;
  display: flex;
  align-items: center;
  justify-content: center;
  background: radial-gradient(circle at center, #0a0a20, #000 70%);
}

#gameCanvas {
  position: absolute;
  width: 100%;
  height: 100%;
  max-width: 500px;
  max-height: 100vh;
  background: transparent;
  z-index: 1;
}

/* Update responsive adjustments */
@media (min-width: 768px) {
  #gameCanvas {
    max-width: 400px;
    height: min(100vh, 800px);
  }
}

@media (max-width: 480px) {
  .menu-btn {
    font-size: 18px;
    padding: 12px 30px;
    margin: 10px 0;
  }
  
  #menuScreen h1 {
    font-size: 36px;
  }
  
  .score-display, .shard-count {
    font-size: 18px;
  }
}
    
    #uiContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
    }
    
    .score-display {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 10px #00f3ff, 0 0 20px #00f3ff;
      pointer-events: none;
    }
    
    .shard-count {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 10px #f300ff, 0 0 20px #f300ff;
      pointer-events: none;
    }
    
    .time-bend-ui {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #00f3ff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      pointer-events: auto;
      touch-action: manipulation;
      z-index: 20;
    }
    
    .time-bend-icon {
      font-size: 30px;
      color: #00f3ff;
      text-shadow: 0 0 10px #00f3ff;
    }
    
    .time-bend-counter {
      position: absolute;
      bottom: -25px;
      font-size: 18px;
      font-weight: bold;
      color: #00f3ff;
      background: rgba(0, 0, 0, 0.5);
      padding: 3px 10px;
      border-radius: 12px;
      border: 1px solid #00f3ff;
    }
    
    .time-bend-cooldown {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 5px solid transparent;
      border-top-color: #00f3ff;
      animation: cooldown 5s linear forwards;
      opacity: 0.7;
    }
    
    @keyframes cooldown {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
		/* Loading Screen Styles */
#loadingScreen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #0c0c2d, #000);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity 0.5s ease;
}

.loading-content {
  text-align: center;
}

.loading-logo {
  font-size: 48px;
  margin-bottom: 30px;
  background: linear-gradient(to right, #00f3ff, #f300ff);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.loading-spinner {
  width: 60px;
  height: 60px;
  border: 4px solid rgba(0, 243, 255, 0.1);
  border-top-color: #00f3ff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 20px;
}

.loading-text {
  color: #aaa;
  font-size: 18px;
  animation: fadeInOut 2s infinite;
}

@keyframes fadeInOut {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 1; }
}

.loading-progress {
  width: 200px;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  margin: 20px auto;
  overflow: hidden;
}

.loading-progress-bar {
  height: 100%;
  background: linear-gradient(to right, #00f3ff, #f300ff);
  border-radius: 2px;
  animation: loadingProgress 2s ease-in-out infinite;
}

@keyframes loadingProgress {
  0% { width: 0%; }
  50% { width: 70%; }
  100% { width: 100%; }
}
		
    /*-- REPLACEMENT FOR: #menuScreen --*/
#menuScreen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #0f0c4d, #000);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  z-index: 100;
  padding: 20px;
  padding-top: 5vh;
  padding-bottom: 5vh;
  text-align: center;
  overflow-y: auto;
  pointer-events: auto;
}
    
    #menuScreen h1 {
      font-size: 48px;
      margin-bottom: 20px;
      background: linear-gradient(to right, #00f3ff, #f300ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
      letter-spacing: 1px;
    }
    
    #menuScreen p {
      font-size: 18px;
      max-width: 90%;
      margin-bottom: 30px;
      color: #aaa;
      line-height: 1.5;
    }
    
    .menu-btn {
      background: linear-gradient(to right, #0047ff, #00a2ff);
      border: none;
      border-radius: 50px;
      color: white;
      font-size: 22px;
      font-weight: bold;
      padding: 15px 40px;
      margin: 15px 0;
      width: 80%;
      max-width: 350px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0, 162, 255, 0.4);
      letter-spacing: 1px;
      pointer-events: auto;
      touch-action: manipulation;
    }
    
    .menu-btn:active {
      transform: scale(0.95);
      box-shadow: 0 3px 10px rgba(0, 162, 255, 0.6);
    }
    
    .menu-btn.fracture {
      background: linear-gradient(to right, #7b00ff, #f300ff);
      box-shadow: 0 5px 15px rgba(243, 0, 255, 0.4);
    }
    
    .menu-btn.fracture:active {
      box-shadow: 0 3px 10px rgba(243, 0, 255, 0.6);
    }
    
    #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: none; /* Initially hidden */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 20px;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    
    .stats-container {
      background: rgba(20, 20, 40, 0.7);
      border-radius: 20px;
      padding: 20px;
      width: 90%;
      max-width: 400px;
      margin-bottom: 25px;
      border: 1px solid #333;
    }
    
    .stat-row {
      display: flex;
      justify-content: space-between;
      padding: 12px 0;
      border-bottom: 1px solid #222;
      font-size: 18px;
    }
    
    .stat-row:last-child {
      border-bottom: none;
    }
    
    .stat-label {
      color: #aaa;
    }
    
    .stat-value {
      font-weight: bold;
      color: #00f3ff;
    }
    
    .stat-value.shards {
      color: #f300ff;
    }
    
    .menu-btn-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 400px;
      gap: 15px;
    }
    
    /*-- REPLACEMENT FOR THE SHARED SCREEN STYLES --*/
#shopScreen, #leaderboardScreen, #authScreen, #profileScreen, #dailyCheckInScreen, #referralScreen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #1a0033, #000);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  z-index: 100;
  padding: 30px 20px 20px;
  overflow-y: auto;
  pointer-events: auto;
}
    
    #shopScreen h1, #leaderboardScreen h1, #authScreen h1, #profileScreen h1, #dailyCheckInScreen h1, #referralScreen h1 {
      font-size: 36px;
      margin-bottom: 25px;
      color: #f300ff;
      text-align: center;
    }
    
    .shop-header, .leaderboard-header {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 400px;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid #333;
    }
    
    .total-shards {
      font-size: 24px;
      background: linear-gradient(to right, #f300ff, #7b00ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 10px rgba(243, 0, 255, 0.3);
    }
    
    .upgrade-card {
      background: rgba(30, 10, 50, 0.7);
      border-radius: 20px;
      width: 100%;
      max-width: 400px;
      padding: 20px;
      margin-bottom: 20px;
      border: 1px solid #440088;
      transition: all 0.3s ease;
    }
    
    .upgrade-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .upgrade-title {
      font-size: 20px;
      font-weight: bold;
      color: #d8a0ff;
    }
    
    .upgrade-cost {
      background: rgba(123, 0, 255, 0.2);
      color: #f300ff;
      padding: 5px 15px;
      border-radius: 20px;
      font-weight: bold;
      border: 1px solid #f300ff;
    }
    
    .upgrade-desc {
      color: #bbb;
      line-height: 1.5;
      margin-bottom: 15px;
      font-size: 16px;
    }
    
    .upgrade-level {
      display: flex;
      align-items: center;
      justify-content: space-between;
      color: #aaa;
      font-size: 14px;
      margin-bottom: 15px;
    }
    
    .buy-btn {
      background: linear-gradient(to right, #7b00ff, #f300ff);
      border: none;
      border-radius: 50px;
      color: white;
      font-size: 18px;
      font-weight: bold;
      padding: 12px 25px;
      width: 100%;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(243, 0, 255, 0.4);
      letter-spacing: 1px;
      pointer-events: auto;
      touch-action: manipulation;
    }
    
    .buy-btn:active {
      transform: scale(0.95);
      box-shadow: 0 3px 10px rgba(243, 0, 255, 0.6);
    }
    
    .buy-btn:disabled {
      background: #555;
      box-shadow: none;
      cursor: not-allowed;
    }
    
    .relic-popup {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(20, 10, 40, 0.9);
      border: 2px solid #f300ff;
      border-radius: 20px;
      padding: 25px;
      width: 85%;
      max-width: 400px;
      text-align: center;
      display: none;
      z-index: 110;
      animation: popup 1.5s ease;
    }
    
    @keyframes popup {
      0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    
    .relic-icon {
      font-size: 48px;
      color: #f300ff;
      margin-bottom: 15px;
      text-shadow: 0 0 15px rgba(243, 0, 255, 0.5);
    }
    
    .relic-title {
      font-size: 28px;
      color: #f300ff;
      margin-bottom: 10px;
    }
    
    .relic-desc {
      color: #ccc;
      line-height: 1.5;
      margin-bottom: 20px;
    }
    
    .relic-btn {
      background: linear-gradient(to right, #7b00ff, #f300ff);
      border: none;
      border-radius: 50px;
      color: white;
      font-size: 18px;
      font-weight: bold;
      padding: 12px 25px;
      width: 80%;
      max-width: 300px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(243, 0, 255, 0.4);
    }
    
    .relic-btn:active {
      transform: scale(0.95);
    }
    
    /* Auth screen specific styles */
    #authScreen {
      background: linear-gradient(135deg, #0f0c4d, #000);
      z-index: 200; /* Higher than other screens */
    }
    
    .auth-container {
      width: 100%;
      max-width: 400px;
      background: rgba(20, 20, 40, 0.7);
      border-radius: 20px;
      padding: 25px;
      margin-bottom: 20px;
    }
    
    .auth-input {
      width: 100%;
      padding: 12px 15px;
      margin-bottom: 15px;
      border-radius: 10px;
      border: 1px solid #333;
      background: rgba(10, 10, 20, 0.7);
      color: white;
      font-size: 16px;
      outline: none;
    }
    
    .auth-input:focus {
      border-color: #00a2ff;
      box-shadow: 0 0 10px rgba(0, 162, 255, 0.4);
    }
    
    .auth-btn {
      width: 100%;
      padding: 12px 15px;
      margin-bottom: 15px;
      border-radius: 50px;
      border: none;
      background: linear-gradient(to right, #0047ff, #00a2ff);
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .auth-btn:active {
      transform: scale(0.95);
    }
    
    .auth-divider {
      display: flex;
      align-items: center;
      margin: 20px 0;
      color: #aaa;
    }
    
    .auth-divider::before, .auth-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: #333;
    }
    
    .auth-divider::before {
      margin-right: 10px;
    }
    
    .auth-divider::after {
      margin-left: 10px;
    }
    
    .social-btn {
      width: 100%;
      padding: 12px 15px;
      margin-bottom: 15px;
      border-radius: 50px;
      border: 1px solid #333;
      background: rgba(10, 10, 20, 0.7);
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .social-btn img {
      width: 24px;
      height: 24px;
      margin-right: 10px;
    }
    
    .social-btn.google {
      background: white;
      color: #333;
    }
    
    .auth-switch {
      margin-top: 20px;
      color: #aaa;
    }
    
    .auth-switch-btn {
      color: #00a2ff;
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      text-decoration: underline;
    }
    
    .auth-error {
      color: #ff4d4d;
      margin-bottom: 15px;
      font-size: 14px;
      display: none;
    }
    
    .user-profile {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      max-width: 400px;
      padding: 15px;
      background: rgba(20, 20, 40, 0.7);
      border-radius: 15px;
      margin-bottom: 20px;
    }
    
    .user-info {
      display: flex;
      align-items: center;
    }
    
    .user-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: #333;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 15px;
      font-size: 24px;
      color: white;
    }
    
    .user-name {
      font-size: 18px;
      font-weight: bold;
    }
    
    .user-email {
      font-size: 14px;
      color: #aaa;
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .logout-btn {
      background: rgba(255, 77, 77, 0.2);
      color: #ff4d4d;
      border: 1px solid #ff4d4d;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 14px;
      cursor: pointer;
    }
    
    /* Leaderboard specific styles */
    .leaderboard-list {
      width: 100%;
      max-width: 400px;
    }
    
    .leaderboard-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px;
      background: rgba(20, 20, 40, 0.7);
      border-radius: 15px;
      margin-bottom: 10px;
    }
    
    .leaderboard-rank {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: linear-gradient(to right, #0047ff, #00a2ff);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
    }
    
    .leaderboard-rank.top-1 {
      background: linear-gradient(to right, #ffd700, #ffaa00);
      color: #000;
    }
    
    .leaderboard-rank.top-2 {
      background: linear-gradient(to right, #c0c0c0, #e0e0e0);
      color: #000;
    }
    
    .leaderboard-rank.top-3 {
      background: linear-gradient(to right, #cd7f32, #e9967a);
      color: #000;
    }
    
    .leaderboard-player {
      flex: 1;
      margin-left: 15px;
      text-align: left;
    }
    
    .leaderboard-name {
      font-size: 16px;
      font-weight: bold;
    }
    
    .leaderboard-score {
      font-size: 14px;
      color: #00f3ff;
    }
    
    .leaderboard-score.shards {
      color: #f300ff;
    }
    
    .leaderboard-tabs {
      display: flex;
      width: 100%;
      max-width: 400px;
      margin-bottom: 20px;
    }
    
    .leaderboard-tab {
      flex: 1;
      padding: 10px;
      text-align: center;
      background: rgba(20, 20, 40, 0.7);
      cursor: pointer;
    }
    
    .leaderboard-tab:first-child {
      border-top-left-radius: 10px;
      border-bottom-left-radius: 10px;
    }
    
    .leaderboard-tab:last-child {
      border-top-right-radius: 10px;
      border-bottom-right-radius: 10px;
    }
    
    .leaderboard-tab.active {
      background: linear-gradient(to right, #0047ff, #00a2ff);
      font-weight: bold;
    }
    
    /* Daily check-in styles */
    .calendar-container {
      width: 100%;
      max-width: 400px;
      background: rgba(20, 20, 40, 0.7);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .calendar-title {
      font-size: 20px;
      font-weight: bold;
    }
    
    .calendar-streak {
      background: rgba(123, 0, 255, 0.2);
      color: #f300ff;
      padding: 5px 15px;
      border-radius: 20px;
      font-weight: bold;
      border: 1px solid #f300ff;
    }
    
    .calendar-days {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    
    .calendar-day {
      width: 48px;
      height: 60px;
      background: rgba(10, 10, 20, 0.7);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .calendar-day.active {
      background: rgba(0, 243, 255, 0.2);
      border: 1px solid #00f3ff;
    }
    
    .calendar-day.completed {
      background: rgba(0, 243, 255, 0.4);
      border: 1px solid #00f3ff;
    }
    
    .calendar-day.current {
      background: linear-gradient(to bottom, rgba(123, 0, 255, 0.4), rgba(243, 0, 255, 0.4));
      border: 1px solid #f300ff;
    }
    
    .day-number {
      font-size: 18px;
      font-weight: bold;
    }
    
    .day-reward {
      font-size: 12px;
      color: #aaa;
    }
    
    .check-icon {
      position: absolute;
      top: -5px;
      right: -5px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #00f3ff;
      color: #000;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .claim-btn {
      background: linear-gradient(to right, #0047ff, #00a2ff);
      border: none;
      border-radius: 50px;
      color: white;
      font-size: 18px;
      font-weight: bold;
      padding: 12px 25px;
      width: 100%;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .claim-btn:disabled {
      background: #555;
      cursor: not-allowed;
    }
    
    /* Referral styles */
    .referral-container {
      width: 100%;
      max-width: 400px;
      background: rgba(20, 20, 40, 0.7);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .referral-header {
      margin-bottom: 15px;
    }
    
    .referral-title {
      font-size: 20px;
      font-weight: bold;
      color: #d8a0ff;
      margin-bottom: 5px;
    }
    
    .referral-desc {
      color: #aaa;
      font-size: 14px;
      line-height: 1.5;
    }
    
    .referral-code-container {
      background: rgba(10, 10, 20, 0.7);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .referral-code {
      font-size: 24px;
      font-weight: bold;
      color: #00f3ff;
      letter-spacing: 2px;
    }
    
    .copy-btn {
      background: rgba(0, 243, 255, 0.2);
      color: #00f3ff;
      border: 1px solid #00f3ff;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 14px;
      cursor: pointer;
    }
    
    .friend-referral {
      margin-top: 20px;
    }
    
    .friend-referral-title {
      font-size: 18px;
      font-weight: bold;
      color: #d8a0ff;
      margin-bottom: 10px;
    }
    
    .friend-code-input {
      width: 100%;
      padding: 12px 15px;
      margin-bottom: 15px;
      border-radius: 10px;
      border: 1px solid #333;
      background: rgba(10, 10, 20, 0.7);
      color: white;
      font-size: 16px;
      outline: none;
    }
    
    .submit-code-btn {
      background: linear-gradient(to right, #7b00ff, #f300ff);
      border: none;
      border-radius: 50px;
      color: white;
      font-size: 16px;
      font-weight: bold;
      padding: 10px 20px;
      width: 100%;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .referral-status {
      margin-top: 15px;
      color: #aaa;
      font-size: 14px;
      text-align: center;
    }
    
    /* Profile screen specific styles */
    .profile-container {
      width: 100%;
      max-width: 400px;
      background: rgba(20, 20, 40, 0.7);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .profile-section {
      margin-bottom: 20px;
      border-bottom: 1px solid #333;
      padding-bottom: 20px;
    }
    
    .profile-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    
    .profile-title {
      font-size: 18px;
      font-weight: bold;
      color: #d8a0ff;
      margin-bottom: 15px;
    }
    
    .profile-field {
      margin-bottom: 15px;
    }
    
    .profile-field-label {
      font-size: 14px;
      color: #aaa;
      margin-bottom: 5px;
    }
    
    .profile-input {
      width: 100%;
      padding: 12px 15px;
      border-radius: 10px;
      border: 1px solid #333;
      background: rgba(10, 10, 20, 0.7);
      color: white;
      font-size: 16px;
      outline: none;
    }
    
    .profile-input:focus {
      border-color: #00a2ff;
      box-shadow: 0 0 10px rgba(0, 162, 255, 0.4);
    }
    
    .save-profile-btn {
      background: linear-gradient(to right, #0047ff, #00a2ff);
      border: none;
      border-radius: 50px;
      color: white;
      font-size: 16px;
      font-weight: bold;
      padding: 10px 20px;
      width: 100%;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 10px;
    }
    
    .profile-error, .profile-success {
      margin-top: 10px;
      font-size: 14px;
      text-align: center;
      display: none;
    }
    
    .profile-error {
      color: #ff4d4d;
    }
    
    .profile-success {
      color: #00ff7f;
    }
    
    /* Loading spinner */
    .spinner {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top-color: #00f3ff;
      animation: spin 1s infinite linear;
      margin: 20px auto;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* User badge in menu */
    .user-badge {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(20, 20, 40, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      cursor: pointer;
      border: 2px solid #00a2ff;
      pointer-events: auto;
    }
    
    /* Time bend effect */
    .time-bend-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(0, 243, 255, 0.1), transparent 70%);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
      z-index: 5;
    }
    
    /* Responsive adjustments */
    @media (max-height: 650px) {
      .menu-btn {
        padding: 12px 30px;
        font-size: 18px;
      }
      #menuScreen h1 {
        font-size: 36px;
      }
      .score-display, .shard-count {
        font-size: 20px;
        top: 15px;
      }
    }
  </style>
</head>
<body>
	
	<!-- Loading Screen -->
<div id="loadingScreen">
  <div class="loading-content">
    <div class="loading-logo">SHATTERLOOP</div>
    <div class="loading-spinner"></div>
    <div class="loading-text" id="loadingText">Initializing quantum matrix...</div>
    <div class="loading-progress">
      <div class="loading-progress-bar"></div>
    </div>
  </div>
</div>
	
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div class="time-bend-effect" id="timeBendEffect"></div>
    <div id="uiContainer">
      <div class="score-display">Score: <span id="scoreValue">0</span></div>
      <div class="shard-count">✦ <span id="shardValue">0</span></div>
      <div class="time-bend-ui" id="timeBendBtn">
        <div class="time-bend-icon">⏳</div>
        <div class="time-bend-cooldown" id="timeBendCooldown"></div>
        <div class="time-bend-counter" id="timeBendCounter">1</div>
      </div>
    </div>
    
    <div id="menuScreen">
      <h1>SHATTERLOOP</h1>
      <p>Guide the Aether Drifter through fractal dimensions. Bend time, collect shards, and master the loop. Choose your path wisely...</p>
      
      <button class="menu-btn" id="safeModeBtn">SAFE PATH</button>
      <button class="menu-btn fracture" id="fractureModeBtn">FRACTURE PATH</button>
      <button class="menu-btn" id="shopBtn">UPGRADES & RELICS</button>
      <button class="menu-btn" id="leaderboardBtn">LEADERBOARD</button>
      <button class="menu-btn" id="dailyCheckInBtn">DAILY CHECK-IN</button>
      <button class="menu-btn" id="referralBtn">REFERRALS</button>
      <div class="user-badge" id="userBadge">👤</div>
    </div>
    
    <div id="gameOverScreen">
      <h2>Run Over ❌</h2>
      <div class="stats-container">
        <div class="stat-row">
          <span class="stat-label">Time Survived:</span>
          <span class="stat-value" id="timeSurvived">0:00</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Final Score:</span>
          <span class="stat-value" id="finalScore">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Shards Collected:</span>
          <span class="stat-value shards" id="shardsCollected">0</span>
        </div>
      </div>
      <div class="menu-btn-container">
        <button class="menu-btn" id="retryBtn">Retry ⟳</button>
        <button class="menu-btn fracture" id="fractureRetryBtn">Take Fracture Path</button>
        <button class="menu-btn" id="menuBtn">Main Menu</button>
      </div>
    </div>
    
    <div id="shopScreen">
      <h1>UPGRADE STATION</h1>
      <div class="shop-header">
        <div>Total Shards:</div>
        <div class="total-shards">✦ <span id="totalShards">0</span></div>
      </div>
      <div class="upgrade-card">
        <div class="upgrade-header">
          <div class="upgrade-title">Time Bend Capacity</div>
          <div class="upgrade-cost" id="timeBendCost">50 ✦</div>
        </div>
        <div class="upgrade-desc">Increase the number of time bends you can use per run.</div>
        <div class="upgrade-level">
            <span>Current Uses: <span id="timeBendLevel">1</span></span>
        </div>
        <button class="buy-btn" id="upgradeTimeBendBtn">Upgrade</button>
      </div>
      <div class="upgrade-card">
        <div class="upgrade-header">
          <div class="upgrade-title">Shard Magnet</div>
          <div class="upgrade-cost" id="magnetCost">30 ✦</div>
        </div>
        <div class="upgrade-desc">Increases collection radius for shards.</div>
         <div class="upgrade-level">
            <span>Current Level: <span id="magnetLevel">0</span></span>
        </div>
        <button class="buy-btn" id="upgradeMagnetBtn">Upgrade</button>
      </div>
      <div class="upgrade-card">
        <div class="upgrade-header">
          <div class="upgrade-title">Phantom Relic</div>
          <div class="upgrade-cost" id="phantomCost">120 ✦</div>
        </div>
        <div class="upgrade-desc">Grants ability to phase through obstacles. Each level adds 1 phase-through per run.</div>
        <div class="upgrade-level">
            <span>Current Level: <span id="phantomLevel">0</span></span>
        </div>
        <button class="buy-btn" id="buyRelicBtn">Upgrade</button>
      </div>
      <button class="menu-btn" id="backToMenuBtn" style="margin-top: 20px;">Back to Main Menu</button>
    </div>
    
    <div id="leaderboardScreen">
      <h1>LEADERBOARD</h1>
      <div class="leaderboard-tabs">
        <div class="leaderboard-tab active" data-type="score">Highest Score</div>
        <div class="leaderboard-tab" data-type="shards">Most Shards</div>
        <div class="leaderboard-tab" data-type="referrals">Top Referrers</div>
      </div>
      <div class="leaderboard-list" id="leaderboardList">
        <div class="spinner"></div>
      </div>
      <button class="menu-btn" id="leaderboardBackBtn" style="margin-top: 20px;">Back to Main Menu</button>
    </div>
    
    <div id="dailyCheckInScreen">
      <h1>DAILY CHECK-IN</h1>
      <div class="calendar-container">
        <div class="calendar-header">
          <div class="calendar-title">Weekly Rewards</div>
          <div class="calendar-streak">Streak: <span id="streakCount">0</span> days</div>
        </div>
        <div class="calendar-days" id="calendarDays">
          <!-- Will be populated dynamically -->
        </div>
        <button class="claim-btn" id="claimDailyBtn">Claim Today's Reward</button>
      </div>
      <button class="menu-btn" id="dailyCheckInBackBtn">Back to Main Menu</button>
    </div>
    
    <div id="referralScreen">
      <h1>REFERRALS</h1>
      <div class="referral-container">
        <div class="referral-header">
          <div class="referral-title">Your Referral Code</div>
          <div class="referral-desc">Share this code with friends. You'll both get 50 shards when they use it!</div>
        </div>
        <div class="referral-code-container">
          <div class="referral-code" id="myReferralCode">LOADING...</div>
          <button class="copy-btn" id="copyCodeBtn">Copy</button>
        </div>
        <div class="referral-stats">
          <div>Friends Referred: <span id="friendsReferred">0</span></div>
          <div>Shards Earned: <span id="referralShards">0</span></div>
        </div>
        
        <div class="friend-referral" id="friendReferralSection">
          <div class="friend-referral-title">Enter Friend's Code</div>
          <input type="text" class="friend-code-input" id="friendCodeInput" placeholder="Enter code" maxlength="8">
          <button class="submit-code-btn" id="submitCodeBtn">Submit</button>
          <div class="referral-status" id="referralStatus"></div>
        </div>
      </div>
      <button class="menu-btn" id="referralBackBtn">Back to Main Menu</button>
    </div>
    
    <div id="profileScreen">
      <h1>PROFILE</h1>
      
      <div class="user-profile">
        <div class="user-info">
          <div class="user-avatar" id="profileAvatar">👤</div>
          <div>
            <div class="user-name" id="profileName">User Name</div>
            <div class="user-email" id="profileEmail">user@example.com</div>
          </div>
        </div>
        <button class="logout-btn" id="profileLogoutBtn">Log Out</button>
      </div>
      
      <div class="profile-container">
        <div class="profile-section">
          <div class="profile-title">Change Username</div>
          <div class="profile-field">
            <div class="profile-field-label">Username</div>
            <input type="text" class="profile-input" id="usernameInput" placeholder="Enter new username">
          </div>
          <button class="save-profile-btn" id="saveUsernameBtn">Save Username</button>
          <div class="profile-error" id="usernameError"></div>
          <div class="profile-success" id="usernameSuccess"></div>
        </div>
        
        <div class="profile-section">
          <div class="profile-title">Change Password</div>
          <div class="profile-field">
            <div class="profile-field-label">Current Password</div>
            <input type="password" class="profile-input" id="currentPasswordInput" placeholder="Enter current password">
          </div>
          <div class="profile-field">
            <div class="profile-field-label">New Password</div>
            <input type="password" class="profile-input" id="newPasswordInput" placeholder="Enter new password">
          </div>
          <div class="profile-field">
            <div class="profile-field-label">Confirm New Password</div>
            <input type="password" class="profile-input" id="confirmNewPasswordInput" placeholder="Confirm new password">
          </div>
          <button class="save-profile-btn" id="savePasswordBtn">Update Password</button>
          <div class="profile-error" id="passwordError"></div>
          <div class="profile-success" id="passwordSuccess"></div>
        </div>
      </div>
      
      <button class="menu-btn" id="profileBackBtn">Back to Main Menu</button>
    </div>
    
    <div id="authScreen">
      <h1 id="authTitle">Sign In</h1>
      
      <div class="auth-container" id="signInContainer">
        <div class="auth-error" id="authError"></div>
        <input type="email" class="auth-input" id="emailInput" placeholder="Email" autocomplete="email">
        <input type="password" class="auth-input" id="passwordInput" placeholder="Password" autocomplete="current-password">
        <button class="auth-btn" id="signInBtn">Sign In</button>
        
        <div class="auth-divider">or</div>
        
        <button class="social-btn google" id="googleSignInBtn">
          <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google">
          Sign in with Google
        </button>
        
        <div class="auth-switch">
          Don't have an account? <button class="auth-switch-btn" id="switchToSignUpBtn">Sign Up</button>
        </div>
      </div>
      
      <div class="auth-container" id="signUpContainer" style="display: none;">
        <div class="auth-error" id="signUpError"></div>
        <input type="text" class="auth-input" id="usernameSignUpInput" placeholder="Username (for leaderboard)" autocomplete="username">
        <input type="email" class="auth-input" id="signUpEmailInput" placeholder="Email" autocomplete="email">
        <input type="password" class="auth-input" id="signUpPasswordInput" placeholder="Password" autocomplete="new-password">
        <input type="password" class="auth-input" id="confirmPasswordInput" placeholder="Confirm Password" autocomplete="new-password">
        <button class="auth-btn" id="signUpBtn">Sign Up</button>
        
        <div class="auth-switch">
          Already have an account? <button class="auth-switch-btn" id="switchToSignInBtn">Sign In</button>
        </div>
      </div>
    </div>
    
    <div class="relic-popup" id="relicPopup">
      <div class="relic-icon">💠</div>
      <div class="relic-title">PHANTOM PHASE</div>
      <div class="relic-desc">You've upgraded the Phantom Phase relic! Tap the icon during gameplay to phase through obstacles.</div>
      <button class="relic-btn" id="relicCloseBtn">Continue</button>
    </div>
  </div>

  <script>
    // Firebase configuration - Replace with your own Firebase project config
    // You can find this in your Firebase project settings -> Project settings -> General -> Your apps
    const firebaseConfig = {
    apiKey: "AIzaSyAqHDZHG626E_U9swnvAbobNxbznWYjByo",
    authDomain: "shatterloop-a7640.firebaseapp.com",
    projectId: "shatterloop-a7640",
    storageBucket: "shatterloop-a7640.firebasestorage.app",
    messagingSenderId: "568996461864",
    appId: "1:568996461864:web:92fc542d589667491f241d",
    measurementId: "G-HRZ1HHS754"
  };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    let currentUser = null;

    // Game constants
    const GAME_WIDTH = 400;
    const GAME_HEIGHT = 800;
    const PLAYER_SIZE = 30;
    
    // Game state
    let gameState = {
      score: 0,
      totalShards: 0,
      mode: 'safe',
      player: { x: GAME_WIDTH / 2, y: GAME_HEIGHT - 100, targetX: GAME_WIDTH / 2, size: PLAYER_SIZE, isAlive: true, trail: [] },
      obstacles: [],
      shardsCollectible: [],
      particles: [],
      timeBend: { maxUses: 1, currentUses: 1, cooldown: 0, maxCooldown: 5000, duration: 2000, active: false },
      upgrades: { timeBendLevel: 1, shardMagnetLevel: 0, phantomPhaseLevel: 0 },
      relics: { phantomPhase: false, phantomPhaseUsed: 0 },
      gameActive: false,
      currentRunShards: 0,
      path: { lastX: GAME_WIDTH / 2, nextY: GAME_HEIGHT - 200 },
      highScore: 0,
      totalShardsCollected: 0,
      speedMultiplier: 1.0,
      gameStartTime: 0,
      dailyCheckIn: {
        lastCheckIn: null,
        streak: 0,
        maxStreak: 0
      },
      referral: {
        code: '',
        friendCode: '',
        referred: 0,
        shardsEarned: 0
      }
			
			// Add passive shard generation system
let passiveShardInterval = null;

function startPassiveShardGeneration() {
  if (passiveShardInterval) clearInterval(passiveShardInterval);
  
  passiveShardInterval = setInterval(() => {
    if (!currentUser) return;
    
    // Safe path: 10 shards per minute, Fracture path: 25 per minute
    const shardsPerMinute = gameState.mode === 'fracture' ? 25 : 10;
    gameState.totalShards += shardsPerMinute;
    
    // Update UI if visible
    if (totalShardsEl) {
      totalShardsEl.textContent = gameState.totalShards;
    }
    
    // Save to database
    if (currentUser) {
      db.collection('users').doc(currentUser.uid).update({
        totalShards: firebase.firestore.FieldValue.increment(shardsPerMinute)
      });
    }
  }, 60000); // Every 60 seconds = 1 minute
}

function stopPassiveShardGeneration() {
  if (passiveShardInterval) {
    clearInterval(passiveShardInterval);
    passiveShardInterval = null;
  }
}
			
    };
    
    // DOM Elements
		
		// Loading screen functions
const loadingScreen = document.getElementById('loadingScreen');
const loadingText = document.getElementById('loadingText');

const loadingMessages = [
  "Initializing quantum matrix...",
  "Calibrating time-bend mechanics...",
  "Loading fractal dimensions...",
  "Synchronizing with the void...",
  "Preparing aether drifter...",
  "Establishing neural link..."
];

let messageIndex = 0;

function showLoadingScreen(message) {
  loadingScreen.style.display = 'flex';
  loadingScreen.style.opacity = '1';
  if (message) {
    loadingText.textContent = message;
  } else {
    // Cycle through messages
    messageIndex = 0;
    loadingText.textContent = loadingMessages[messageIndex];
    const messageInterval = setInterval(() => {
      messageIndex = (messageIndex + 1) % loadingMessages.length;
      loadingText.textContent = loadingMessages[messageIndex];
    }, 2000);
    loadingScreen.messageInterval = messageInterval;
  }
}

function hideLoadingScreen() {
  if (loadingScreen.messageInterval) {
    clearInterval(loadingScreen.messageInterval);
  }
  loadingScreen.style.opacity = '0';
  setTimeout(() => {
    loadingScreen.style.display = 'none';
  }, 500);
}
		
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreValue = document.getElementById('scoreValue');
    const shardValue = document.getElementById('shardValue');
    const timeBendBtn = document.getElementById('timeBendBtn');
    const timeBendCounter = document.getElementById('timeBendCounter');
    const timeBendCooldown = document.getElementById('timeBendCooldown');
    const timeBendEffect = document.getElementById('timeBendEffect');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScore = document.getElementById('finalScore');
    const shardsCollected = document.getElementById('shardsCollected');
    const timeSurvived = document.getElementById('timeSurvived');
    const totalShardsEl = document.getElementById('totalShards');
    
    const menuScreen = document.getElementById('menuScreen');
    const safeModeBtn = document.getElementById('safeModeBtn');
    const fractureModeBtn = document.getElementById('fractureModeBtn');
    const shopBtn = document.getElementById('shopBtn');
    const leaderboardBtn = document.getElementById('leaderboardBtn');
    const dailyCheckInBtn = document.getElementById('dailyCheckInBtn');
    const referralBtn = document.getElementById('referralBtn');
    const userBadge = document.getElementById('userBadge');
    const retryBtn = document.getElementById('retryBtn');
    const fractureRetryBtn = document.getElementById('fractureRetryBtn');
    const menuBtn = document.getElementById('menuBtn');
    
    const shopScreen = document.getElementById('shopScreen');
    const backToMenuBtn = document.getElementById('backToMenuBtn');
    
    const leaderboardScreen = document.getElementById('leaderboardScreen');
    const leaderboardList = document.getElementById('leaderboardList');
    const leaderboardTabs = document.querySelectorAll('.leaderboard-tab');
    const leaderboardBackBtn = document.getElementById('leaderboardBackBtn');
    
    const dailyCheckInScreen = document.getElementById('dailyCheckInScreen');
    const calendarDays = document.getElementById('calendarDays');
    const streakCount = document.getElementById('streakCount');
    const claimDailyBtn = document.getElementById('claimDailyBtn');
    const dailyCheckInBackBtn = document.getElementById('dailyCheckInBackBtn');
    
    const referralScreen = document.getElementById('referralScreen');
    const myReferralCode = document.getElementById('myReferralCode');
    const copyCodeBtn = document.getElementById('copyCodeBtn');
    const friendsReferred = document.getElementById('friendsReferred');
    const referralShards = document.getElementById('referralShards');
    const friendReferralSection = document.getElementById('friendReferralSection');
    const friendCodeInput = document.getElementById('friendCodeInput');
    const submitCodeBtn = document.getElementById('submitCodeBtn');
    const referralStatus = document.getElementById('referralStatus');
    const referralBackBtn = document.getElementById('referralBackBtn');
    
    const profileScreen = document.getElementById('profileScreen');
    const profileAvatar = document.getElementById('profileAvatar');
    const profileName = document.getElementById('profileName');
    const profileEmail = document.getElementById('profileEmail');
    const usernameInput = document.getElementById('usernameInput');
    const saveUsernameBtn = document.getElementById('saveUsernameBtn');
    const usernameError = document.getElementById('usernameError');
    const usernameSuccess = document.getElementById('usernameSuccess');
    const currentPasswordInput = document.getElementById('currentPasswordInput');
    const newPasswordInput = document.getElementById('newPasswordInput');
    const confirmNewPasswordInput = document.getElementById('confirmNewPasswordInput');
    const savePasswordBtn = document.getElementById('savePasswordBtn');
    const passwordError = document.getElementById('passwordError');
    const passwordSuccess = document.getElementById('passwordSuccess');
    const profileLogoutBtn = document.getElementById('profileLogoutBtn');
    const profileBackBtn = document.getElementById('profileBackBtn');
    
    const authScreen = document.getElementById('authScreen');
    const authTitle = document.getElementById('authTitle');
    const signInContainer = document.getElementById('signInContainer');
    const signUpContainer = document.getElementById('signUpContainer');
    
    const emailInput = document.getElementById('emailInput');
    const passwordInput = document.getElementById('passwordInput');
    const signInBtn = document.getElementById('signInBtn');
    const googleSignInBtn = document.getElementById('googleSignInBtn');
    const switchToSignUpBtn = document.getElementById('switchToSignUpBtn');
    
    const usernameSignUpInput = document.getElementById('usernameSignUpInput');
    const signUpEmailInput = document.getElementById('signUpEmailInput');
    const signUpPasswordInput = document.getElementById('signUpPasswordInput');
    const confirmPasswordInput = document.getElementById('confirmPasswordInput');
    const signUpBtn = document.getElementById('signUpBtn');
    const switchToSignInBtn = document.getElementById('switchToSignInBtn');
    
    const authError = document.getElementById('authError');
    const signUpError = document.getElementById('signUpError');
    
    const timeBendCostEl = document.getElementById('timeBendCost');
    const timeBendLevelEl = document.getElementById('timeBendLevel');
    const magnetCostEl = document.getElementById('magnetCost');
    const magnetLevelEl = document.getElementById('magnetLevel');
    const phantomCostEl = document.getElementById('phantomCost');
    const phantomLevelEl = document.getElementById('phantomLevel');
    const upgradeTimeBendBtn = document.getElementById('upgradeTimeBendBtn');
    const upgradeMagnetBtn = document.getElementById('upgradeMagnetBtn');
    const buyRelicBtn = document.getElementById('buyRelicBtn');
    
    function initGame() {
  // Show loading screen immediately
  showLoadingScreen();
  
  // Set up dynamic canvas sizing
  setupCanvasSize();
  window.addEventListener('resize', setupCanvasSize);
  
  // Monitor network status
  window.addEventListener('online', () => {
    console.log('Network connection restored');
  });

window.addEventListener('offline', () => {
  console.log('Network connection lost');
  if (gameState.gameActive) {
    endGame();
  }
  alert('Network connection lost. Please check your internet connection.');
});
			
      canvas.width = GAME_WIDTH;
      canvas.height = GAME_HEIGHT;
      setupEventListeners();
      setupAuthListeners();
      gameLoop();
      
      // Show auth screen first
      showAuthScreen();
      
      // Listen for auth state changes
auth.onAuthStateChanged(user => {
  if (user) {
    currentUser = user;
    // Load user data and wait for it to complete
    loadUserData().then(() => {
      updateUserProfile();
      if (authScreen.style.display === 'flex') {
        showMenu();
      }
      hideLoadingScreen();
    }).catch(error => {
      console.error('Error loading user data:', error);
      hideLoadingScreen();
    });
  } else {
    currentUser = null;
    stopPassiveShardGeneration(); // Stop passive generation when logged out
    hideLoadingScreen();
    if (authScreen.style.display !== 'flex') {
      showAuthScreen();
    }
  }
  updateAuthUI();
});
    }
    
		function setupCanvasSize() {
  const container = document.getElementById('gameContainer');
  const canvas = document.getElementById('gameCanvas');
  
  // Calculate optimal size
  const maxWidth = 500;
  const maxHeight = 800;
  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;
  
  let width = Math.min(screenWidth, maxWidth);
  let height = Math.min(screenHeight, maxHeight);
  
  // Maintain aspect ratio
  const aspectRatio = maxWidth / maxHeight;
  if (width / height > aspectRatio) {
    width = height * aspectRatio;
  } else {
    height = width / aspectRatio;
  }
  
  // Update canvas actual size
  canvas.width = GAME_WIDTH;
  canvas.height = GAME_HEIGHT;
  
  // Update canvas display size
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';
}
		
    function setupAuthListeners() {
      // Sign In
      signInBtn.addEventListener('click', () => {
  const email = emailInput.value;
  const password = passwordInput.value;
  
  if (!email || !password) {
    showAuthError('Please enter both email and password');
    return;
  }
  
  showLoadingScreen('Signing in...');
  
  auth.signInWithEmailAndPassword(email, password)
    .then(() => {
      hideLoadingScreen();
      authScreen.style.display = 'none';
      menuScreen.style.display = 'flex';
    })
    .catch(error => {
      hideLoadingScreen();
      showAuthError(error.message);
    });
});
      
      // Google Sign In
googleSignInBtn.addEventListener('click', () => {
  const provider = new firebase.auth.GoogleAuthProvider();
  showLoadingScreen('Connecting to Google...');
  
  auth.signInWithPopup(provider)
    .then((result) => {
      // Check if this is a new user
      const isNewUser = result.additionalUserInfo.isNewUser;
      if (isNewUser) {
        // Generate username from email or name
        let username = '';
        if (result.user.displayName) {
          username = result.user.displayName.replace(/\s+/g, '').toLowerCase() + Math.floor(Math.random() * 1000);
        } else if (result.user.email) {
          username = result.user.email.split('@')[0] + Math.floor(Math.random() * 1000);
        } else {
          username = 'user' + Math.floor(Math.random() * 10000);
        }
        
        // Generate referral code
        const referralCode = generateReferralCode();
        
        // Create user document
        createNewUserDocument(result.user.uid, {
          displayName: result.user.displayName || 'Anonymous',
          email: result.user.email,
          username: username,
          referralCode: referralCode,
          totalShards: 0,
          highScore: 0
        });
      }
      
      hideLoadingScreen();
      authScreen.style.display = 'none';
      menuScreen.style.display = 'flex';
    })
    .catch(error => {
      hideLoadingScreen();
      showAuthError(error.message);
    });
});
      
      // Sign Up
      signUpBtn.addEventListener('click', () => {
        const username = usernameSignUpInput.value;
        const email = signUpEmailInput.value;
        const password = signUpPasswordInput.value;
        const confirmPassword = confirmPasswordInput.value;
        
        if (!username || !email || !password || !confirmPassword) {
          showSignUpError('Please fill in all fields');
          return;
        }
        
        if (password !== confirmPassword) {
          showSignUpError('Passwords do not match');
          return;
        }
				
				// Add password strength check
if (password.length < 6) {
  showSignUpError('Password must be at least 6 characters long');
  return;
}
        
        // Check if username is available
        checkUsernameAvailability(username)
          .then(isAvailable => {
            if (!isAvailable) {
              showSignUpError('Username is already taken');
              return;
            }
            
            // Create user
            auth.createUserWithEmailAndPassword(email, password)
              .then((userCredential) => {
                // Generate referral code
                const referralCode = generateReferralCode();
                
                // Create user document
                return createNewUserDocument(userCredential.user.uid, {
                  displayName: username,
                  email: email,
                  username: username,
                  referralCode: referralCode,
                  totalShards: 0,
                  highScore: 0
                }).then(() => {
                  // Update display name
                  return userCredential.user.updateProfile({
                    displayName: username
                  }).then(() => {
                    authScreen.style.display = 'none';
                    menuScreen.style.display = 'flex';
                  });
                });
              })
              .catch(error => {
                showSignUpError(error.message);
              });
          })
          .catch(error => {
            showSignUpError('Error checking username: ' + error.message);
          });
      });
      
      // Logout
      profileLogoutBtn.addEventListener('click', () => {
        auth.signOut().then(() => {
          profileScreen.style.display = 'none';
          showAuthScreen();
        }).catch((error) => {
          console.error('Logout error:', error);
        });
      });
      
      // Switch between sign in and sign up
      switchToSignUpBtn.addEventListener('click', () => {
        signInContainer.style.display = 'none';
        signUpContainer.style.display = 'block';
        authTitle.textContent = 'Sign Up';
      });
      
      switchToSignInBtn.addEventListener('click', () => {
        signUpContainer.style.display = 'none';
        signInContainer.style.display = 'block';
        authTitle.textContent = 'Sign In';
      });
      
      // User badge click
      userBadge.addEventListener('click', () => {
        showProfileScreen();
      });
      
      // Profile buttons
      saveUsernameBtn.addEventListener('click', updateUsername);
      savePasswordBtn.addEventListener('click', updatePassword);
      profileBackBtn.addEventListener('click', showMenu);
      
      // Referral buttons
      copyCodeBtn.addEventListener('click', copyReferralCode);
      submitCodeBtn.addEventListener('click', submitReferralCode);
      referralBackBtn.addEventListener('click', showMenu);
      
      // Daily check-in buttons
      claimDailyBtn.addEventListener('click', claimDailyReward);
      dailyCheckInBackBtn.addEventListener('click', showMenu);
    }
    
    function createNewUserDocument(uid, userData) {
  return db.collection('users').doc(uid).set({
    displayName: userData.displayName,
    email: userData.email,
    username: userData.username,
    referralCode: userData.referralCode, // Keep for backward compatibility
    totalShards: 0,
    totalShardsCollected: 0,
    highScore: 0,
    upgrades: {
      timeBendLevel: 1,
      shardMagnetLevel: 0,
      phantomPhaseLevel: 0
    },
    dailyCheckIn: {
      lastCheckIn: null,
      streak: 0,
      maxStreak: 0
    },
    referral: {
      code: userData.referralCode,
      friendCode: '',
      referred: 0,
      shardsEarned: 0
    },
    createdAt: firebase.firestore.FieldValue.serverTimestamp()
  });
}
    
    function checkUsernameAvailability(username) {
      return db.collection('users')
        .where('username', '==', username)
        .get()
        .then(snapshot => {
          return snapshot.empty;
        });
    }
    
    function generateReferralCode() {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let code = '';
      for (let i = 0; i < 8; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return code;
    }
    
    function updateUsername() {
  const newUsername = usernameInput.value.trim();
  
  if (!newUsername) {
    showProfileError(usernameError, 'Username cannot be empty');
    return;
  }
  
  // Validate username length and characters
  if (newUsername.length < 3 || newUsername.length > 20) {
    showProfileError(usernameError, 'Username must be 3-20 characters long');
    return;
  }
  
  if (!/^[a-zA-Z0-9_]+$/.test(newUsername)) {
    showProfileError(usernameError, 'Username can only contain letters, numbers, and underscores');
    return;
  }
  
  // Check if username is available
  checkUsernameAvailability(newUsername)
    .then(isAvailable => {
      if (!isAvailable && newUsername !== currentUser.displayName) {
        showProfileError(usernameError, 'Username is already taken');
        return;
      }
      
      // Update username in Firestore
      db.collection('users').doc(currentUser.uid).update({
        username: newUsername,
        displayName: newUsername
      })
      .then(() => {
        // Update display name in Firebase Auth
        return currentUser.updateProfile({
          displayName: newUsername
        }).then(() => {
          updateUserProfile();
          showProfileSuccess(usernameSuccess, 'Username updated successfully');
          usernameInput.value = '';
        });
      })
      .catch(error => {
        showProfileError(usernameError, 'Error updating username: ' + error.message);
      });
    })
    .catch(error => {
      showProfileError(usernameError, 'Error checking username: ' + error.message);
    });
}
    
    function updatePassword() {
      const currentPassword = currentPasswordInput.value;
      const newPassword = newPasswordInput.value;
      const confirmNewPassword = confirmNewPasswordInput.value;
      
      if (!currentPassword || !newPassword || !confirmNewPassword) {
        showProfileError(passwordError, 'Please fill in all password fields');
        return;
      }
      
      if (newPassword !== confirmNewPassword) {
        showProfileError(passwordError, 'New passwords do not match');
        return;
      }
      
      // Reauthenticate user
      const credential = firebase.auth.EmailAuthProvider.credential(
        currentUser.email,
        currentPassword
      );
      
      currentUser.reauthenticateWithCredential(credential)
        .then(() => {
          // Update password
          return currentUser.updatePassword(newPassword)
            .then(() => {
              showProfileSuccess(passwordSuccess, 'Password updated successfully');
              currentPasswordInput.value = '';
              newPasswordInput.value = '';
              confirmNewPasswordInput.value = '';
            })
            .catch(error => {
              showProfileError(passwordError, 'Error updating password: ' + error.message);
            });
        })
        .catch(error => {
          showProfileError(passwordError, 'Current password is incorrect');
        });
    }
    
    function copyReferralCode() {
      const code = myReferralCode.textContent;
      navigator.clipboard.writeText(code)
        .then(() => {
          copyCodeBtn.textContent = 'Copied!';
          setTimeout(() => {
            copyCodeBtn.textContent = 'Copy';
          }, 2000);
        })
        .catch(err => {
          console.error('Could not copy text: ', err);
        });
    }
    
    // [FIXED] Corrected the referral code submission logic
    function submitReferralCode() {
    if (!currentUser) return;

    const code = friendCodeInput.value.trim().toUpperCase();

    if (!code) {
        updateReferralStatus('Please enter a referral code', 'error');
        return;
    }

    db.collection('users').doc(currentUser.uid).get()
    .then(doc => {
        if (!doc.exists) {
            throw new Error("Current user not found in database.");
        }
        const userData = doc.data();

        if (userData.referral && userData.referral.friendCode) {
            updateReferralStatus('You have already used a referral code', 'error');
            return Promise.reject();
        }

        if (userData.referral && code === userData.referral.code) {
            updateReferralStatus('You cannot use your own referral code', 'error');
            return Promise.reject();
        }

        // Find the referrer - check both fields for backward compatibility
        return db.collection('users')
            .where('referralCode', '==', code)
            .get()
            .then(snapshot => {
                if (snapshot.empty) {
                    // Try the nested field
                    return db.collection('users')
                        .where('referral.code', '==', code)
                        .get();
                }
                return snapshot;
            });
    })
    .then(snapshot => {
        if (!snapshot) return;

        if (snapshot.empty) {
            updateReferralStatus('Invalid referral code', 'error');
            return Promise.reject();
        }

        const referrerDoc = snapshot.docs[0];

        const userUpdatePromise = db.collection('users').doc(currentUser.uid).update({
            'referral.friendCode': code,
            'totalShards': firebase.firestore.FieldValue.increment(50)
        });

        const referrerUpdatePromise = referrerDoc.ref.update({
            'referral.referred': firebase.firestore.FieldValue.increment(1),
            'referral.shardsEarned': firebase.firestore.FieldValue.increment(50),
            'totalShards': firebase.firestore.FieldValue.increment(50)
        });

        return Promise.all([userUpdatePromise, referrerUpdatePromise]);
    })
    .then((result) => {
        if (!result) return;

        gameState.totalShards += 50;
        updateReferralStatus('Success! You received 50 shards', 'success');
        friendCodeInput.value = '';
        friendReferralSection.innerHTML = `<div class="referral-status">You have used the referral code: ${code}</div>`;
        loadUserData();
    })
    .catch(error => {
        if (error && error.message) {
            console.error('Error submitting referral code:', error);
            updateReferralStatus('Error: ' + error.message, 'error');
        }
    });
}

    
    function updateReferralStatus(message, type) {
      referralStatus.textContent = message;
      referralStatus.style.color = type === 'error' ? '#ff4d4d' : '#00ff7f';
      referralStatus.style.display = 'block';
      
      setTimeout(() => {
        referralStatus.style.display = 'none';
      }, 5000);
    }
    
    //-- REPLACEMENT FOR: claimDailyReward() --//
function claimDailyReward() {
  if (!currentUser) return;

  claimDailyBtn.disabled = true;
  claimDailyBtn.textContent = 'Claiming...';

  const userDocRef = db.collection('users').doc(currentUser.uid);

  userDocRef.get()
    .then(doc => {
      if (!doc.exists) {
        throw new Error("User data not found. Please reload the page.");
      }

      const userData = doc.data();
      const checkInData = userData.dailyCheckIn || { lastCheckIn: null, streak: 0, maxStreak: 0 };
      
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      
      let lastCheckInDate = null;
      if (checkInData.lastCheckIn) {
        // Handle both Firestore Timestamp and regular Date objects
        const lastCheckInTimestamp = checkInData.lastCheckIn.toDate ? 
          checkInData.lastCheckIn.toDate() : new Date(checkInData.lastCheckIn);
        lastCheckInDate = new Date(
          lastCheckInTimestamp.getFullYear(), 
          lastCheckInTimestamp.getMonth(), 
          lastCheckInTimestamp.getDate()
        );
      }

      // Check if already claimed today
      if (lastCheckInDate && lastCheckInDate.getTime() === today.getTime()) {
        throw new Error("Reward already claimed for today!");
      }

      // Calculate new streak
      let newStreak = 1;
      if (lastCheckInDate) {
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        
        if (lastCheckInDate.getTime() === yesterday.getTime()) {
          newStreak = (checkInData.streak || 0) + 1;
        }
      }

      // Cap streak at 7 days and get reward
      const effectiveStreak = Math.min(newStreak, 7);
      const rewards = [20, 20, 20, 30, 30, 50, 100];
      const reward = rewards[effectiveStreak - 1];

      const updatePayload = {
        'dailyCheckIn.lastCheckIn': firebase.firestore.Timestamp.now(),
        'dailyCheckIn.streak': newStreak,
        'dailyCheckIn.maxStreak': Math.max(newStreak, checkInData.maxStreak || 0),
        'totalShards': firebase.firestore.FieldValue.increment(reward),
        'lastUpdated': firebase.firestore.FieldValue.serverTimestamp()
      };
      
      return userDocRef.update(updatePayload).then(() => {
        // Update local state
        gameState.totalShards += reward;
        gameState.dailyCheckIn.streak = newStreak;
        gameState.dailyCheckIn.lastCheckIn = now;
        
        // Update UI
        claimDailyBtn.textContent = `Claimed ${reward} Shards!`;
        claimDailyBtn.style.background = 'linear-gradient(to right, #00ff7f, #32cd32)';
        
        // Refresh the UI after a delay
        setTimeout(() => {
          updateDailyCheckInUI();
          if (totalShardsEl) {
            totalShardsEl.textContent = gameState.totalShards;
          }
        }, 1000);
        
        return reward;
      });
    })
    .catch(error => {
      console.error('Error claiming daily reward:', error);
      claimDailyBtn.textContent = error.message || 'Error! Try Again';
      claimDailyBtn.style.background = 'linear-gradient(to right, #ff4d4d, #c60000)';

      setTimeout(() => {
        claimDailyBtn.disabled = false;
        claimDailyBtn.textContent = "Claim Today's Reward";
        claimDailyBtn.style.background = '';
      }, 3000);
    });
}
    
    //-- REPLACEMENT FOR: updateDailyCheckInUI() --//
function updateDailyCheckInUI() {
    if (!currentUser) return;

    db.collection('users').doc(currentUser.uid).get()
    .then(doc => {
        if (!doc.exists) {
            console.error("User document not found for UI update.");
            return;
        }

        const userData = doc.data();
        const checkInData = userData.dailyCheckIn || { lastCheckIn: null, streak: 0 };
        const userStreak = checkInData.streak || 0;

        streakCount.textContent = `${userStreak} days`;

        const now = new Date();
        const todayDate = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
        const lastCheckIn = checkInData.lastCheckIn ? checkInData.lastCheckIn.toDate() : null;
        const lastCheckInDay = lastCheckIn ? new Date(lastCheckIn.getFullYear(), lastCheckIn.getMonth(), lastCheckIn.getDate()).getTime() : 0;
        const hasClaimedToday = lastCheckInDay === todayDate;

        calendarDays.innerHTML = '';
        const rewards = [20, 20, 20, 30, 30, 50, 100]; 

        for (let i = 1; i <= 7; i++) {
            const dayDiv = document.createElement('div');
            dayDiv.className = 'calendar-day';

            if (i <= userStreak) {
                dayDiv.classList.add('completed');
                dayDiv.innerHTML += '<div class="check-icon">✓</div>';
            } 
            else if (i === userStreak + 1 && !hasClaimedToday) {
                dayDiv.classList.add('current');
            }

            dayDiv.innerHTML += `
              <div class="day-number">Day ${i}</div>
              <div class="day-reward">${rewards[i - 1]} ✦</div>
            `;
            calendarDays.appendChild(dayDiv);
        }
        
        if (hasClaimedToday) {
            claimDailyBtn.disabled = true;
            let claimedRewardText = "Already Claimed Today";
            if(userStreak > 0) {
                 const rewardIndex = Math.min(userStreak - 1, 6);
                 const reward = rewards[rewardIndex];
                 claimedRewardText = `Claimed ${reward} Shards Today!`;
            }
            claimDailyBtn.textContent = claimedRewardText;

        } else {
            claimDailyBtn.textContent = "Claim Today's Reward";
            claimDailyBtn.disabled = false;
        }
    })
    .catch(error => {
        console.error('Error updating daily check-in UI:', error);
    });
}
    
    function showAuthError(message) {
      authError.textContent = message;
      authError.style.display = 'block';
      setTimeout(() => {
        authError.style.display = 'none';
      }, 5000);
    }
    
    function showSignUpError(message) {
      signUpError.textContent = message;
      signUpError.style.display = 'block';
      setTimeout(() => {
        signUpError.style.display = 'none';
      }, 5000);
    }
    
    function showProfileError(element, message) {
      element.textContent = message;
      element.style.display = 'block';
      setTimeout(() => {
        element.style.display = 'none';
      }, 5000);
    }
    
    function showProfileSuccess(element, message) {
      element.textContent = message;
      element.style.display = 'block';
      setTimeout(() => {
        element.style.display = 'none';
      }, 5000);
    }
    
    function updateAuthUI() {
      if (currentUser) {
        // User is signed in
        signInContainer.style.display = 'none';
        signUpContainer.style.display = 'none';
        
        // Update user badge in menu
        userBadge.innerHTML = currentUser.photoURL ? 
          `<img src="${currentUser.photoURL}" alt="${currentUser.displayName}" style="width: 100%; height: 100%; border-radius: 50%;">` : 
          (currentUser.displayName ? currentUser.displayName.charAt(0).toUpperCase() : '👤');
      } else {
        // User is signed out
        signInContainer.style.display = 'block';
        signUpContainer.style.display = 'none';
        userBadge.textContent = '👤';
        authTitle.textContent = 'Sign In';
      }
    }
    
    function loadUserData() {
  if (!currentUser) return;
  
  return db.collection('users').doc(currentUser.uid).get()
    .then((doc) => {
      if (doc.exists) {
        const userData = doc.data();
        
        // Ensure all data is properly loaded
        gameState.totalShards = userData.totalShards || 0;
        gameState.upgrades.timeBendLevel = userData.upgrades?.timeBendLevel || 1;
        gameState.upgrades.shardMagnetLevel = userData.upgrades?.shardMagnetLevel || 0;
        gameState.upgrades.phantomPhaseLevel = userData.upgrades?.phantomPhaseLevel || 0;
        gameState.relics.phantomPhase = (userData.upgrades?.phantomPhaseLevel || 0) > 0;
        gameState.highScore = userData.highScore || 0;
        gameState.dailyCheckIn = userData.dailyCheckIn || { lastCheckIn: null, streak: 0, maxStreak: 0 };
        gameState.referral = userData.referral || { code: generateReferralCode(), friendCode: '', referred: 0, shardsEarned: 0 };
        
        // Update all UI elements
        updateShopUI();
        updateUserProfile();
        updateReferralUI();
        
        // Start passive shard generation
        startPassiveShardGeneration();
        
        console.log('User data loaded successfully');
        return userData;
      } else {
        // Create user document if it doesn't exist
        const referralCode = generateReferralCode();
        return createNewUserDocument(currentUser.uid, {
          displayName: currentUser.displayName || 'Anonymous',
          email: currentUser.email,
          username: currentUser.displayName || 'Anonymous',
          referralCode: referralCode,
          totalShards: 0,
          highScore: 0
        }).then(() => {
          gameState.referral.code = referralCode;
          startPassiveShardGeneration();
        });
      }
    })
    .catch((error) => {
      console.error("Error loading user data:", error);
      throw error;
    });
}
    
    function updateUserProfile() {
      if (!currentUser) return;
      
      // Update profile screen
      profileName.textContent = currentUser.displayName || 'Anonymous';
      profileEmail.textContent = currentUser.email || '';
      
      if (currentUser.photoURL) {
        profileAvatar.innerHTML = `<img src="${currentUser.photoURL}" alt="${currentUser.displayName}" style="width: 100%; height: 100%; border-radius: 50%;">`;
      } else {
        profileAvatar.textContent = currentUser.displayName ? currentUser.displayName.charAt(0).toUpperCase() : '👤';
      }
      
      // Update placeholder in username input
      usernameInput.placeholder = currentUser.displayName || 'Enter new username';
    }
    
    function updateReferralUI() {
  if (!currentUser) return;
  
  myReferralCode.textContent = gameState.referral.code || 'LOADING...';
  friendsReferred.textContent = gameState.referral.referred || '0';
  referralShards.textContent = gameState.referral.shardsEarned || '0';

  if (gameState.referral.friendCode) {
    friendReferralSection.innerHTML = '<div class="referral-status">You have used the referral code: ' + gameState.referral.friendCode + '</div>';
  } else {
    // Check if we need to recreate the input section
    const existingInput = document.getElementById('friendCodeInput');
    if (!existingInput) {
      friendReferralSection.innerHTML = `
        <div class="friend-referral-title">Enter Friend's Code</div>
        <input type="text" class="friend-code-input" id="friendCodeInput" placeholder="Enter code" maxlength="8">
        <button class="submit-code-btn" id="submitCodeBtn">Submit</button>
        <div class="referral-status" id="referralStatus"></div>
      `;
      
      // Remove any existing event listener and add new one
      const newSubmitBtn = document.getElementById('submitCodeBtn');
      if (newSubmitBtn) {
        newSubmitBtn.removeEventListener('click', submitReferralCode);
        newSubmitBtn.addEventListener('click', submitReferralCode);
      }
    }
  }
}
    
    function saveUserData() {
    if (!currentUser) return;
    
    const updates = {
        totalShards: gameState.totalShards,
        highScore: gameState.highScore,
        totalShardsCollected: gameState.totalShardsCollected || gameState.totalShards,
        upgrades: {
            timeBendLevel: gameState.upgrades.timeBendLevel,
            shardMagnetLevel: gameState.upgrades.shardMagnetLevel,
            phantomPhaseLevel: gameState.upgrades.phantomPhaseLevel
        },
        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
    };
    
    db.collection('users').doc(currentUser.uid).update(updates)
        .catch((error) => {
            console.error("Error saving user data:", error);
        });
}
    
function formatScore(milliseconds) {
  const seconds = milliseconds / 1000;
  return `${seconds.toFixed(3)}s`;
}

    // [FIXED] Leaderboard now formats the time-based score
    function updateLeaderboard(type = 'score') {
  leaderboardList.innerHTML = '<div class="spinner"></div>';
  
  let field, collection;
  
  if (type === 'referrals') {
    collection = 'users';
    field = 'referral.referred';
  } else {
    collection = 'users';
    field = type === 'score' ? 'highScore' : 'totalShards';
  }
  
  // Force fresh data by using current timestamp
  db.collection(collection)
    .where('lastUpdated', '>', new Date(0)) // Get all records with any timestamp
    .orderBy('lastUpdated', 'desc')
    .orderBy(field, 'desc')
    .limit(10)
    .get({ source: 'server' }) // Force server fetch, not cache
    .then((snapshot) => {
      leaderboardList.innerHTML = '';
      
      if (snapshot.empty) {
        leaderboardList.innerHTML = '<p style="text-align: center; color: #aaa;">No data available</p>';
        return;
      }
      
      // Sort by the actual field after fetching
      const docs = snapshot.docs.sort((a, b) => {
        const aVal = type === 'score' ? (a.data().highScore || 0) : 
                    type === 'shards' ? (a.data().totalShards || 0) :
                    (a.data().referral?.referred || 0);
        const bVal = type === 'score' ? (b.data().highScore || 0) : 
                    type === 'shards' ? (b.data().totalShards || 0) :
                    (b.data().referral?.referred || 0);
        return bVal - aVal;
      });
      
      docs.forEach((doc, index) => {
        const data = doc.data();
        const isCurrentUser = currentUser && doc.id === currentUser.uid;
        const displayName = data.username || data.displayName || 'Anonymous';
        
        let scoreDisplay;
        if (type === 'score') {
          scoreDisplay = formatScore(data.highScore || 0);
        } else if (type === 'shards') {
          scoreDisplay = '✦ ' + (data.totalShards || 0);
        } else if (type === 'referrals') {
          scoreDisplay = (data.referral?.referred || 0) + ' referrals';
        }
        
        const itemHTML = `
          <div class="leaderboard-item ${isCurrentUser ? 'current-user' : ''}">
            <div class="leaderboard-rank ${index < 3 ? 'top-' + (index + 1) : ''}">${index + 1}</div>
            <div class="leaderboard-player">
              <div class="leaderboard-name">${displayName}</div>
              <div class="leaderboard-score ${type === 'shards' ? 'shards' : ''}">
                ${scoreDisplay}
              </div>
            </div>
          </div>
        `;
        
        leaderboardList.innerHTML += itemHTML;
      });
    })
    .catch((error) => {
      console.error("Error getting leaderboard:", error);
      leaderboardList.innerHTML = '<p style="text-align: center; color: #ff4d4d;">Error loading leaderboard. Please try again.</p>';
    });
}
    
    // [FIXED] Game start time is now recorded for fair scoring
    function resetGameState() {
  gameState.score = 0;
  gameState.currentRunShards = 0;
  gameState.gameStartTime = Date.now();
  gameState.speedMultiplier = 1.0;
  gameState.player = { x: GAME_WIDTH / 2, y: GAME_HEIGHT - 100, targetX: GAME_WIDTH / 2, size: PLAYER_SIZE, isAlive: true, trail: [] };
  gameState.obstacles = [];
  gameState.shardsCollectible = [];
  gameState.particles = [];
  gameState.timeBend.maxUses = gameState.upgrades.timeBendLevel;
  gameState.timeBend.currentUses = gameState.timeBend.maxUses;
  gameState.timeBend.cooldown = 0;
  gameState.timeBend.active = false;
  gameState.relics.phantomPhaseUsed = 0;
  gameState.path = { lastX: GAME_WIDTH / 2, nextY: GAME_HEIGHT - 200 };
  gameState.gameActive = true;
  
  scoreValue.textContent = '0';
  shardValue.textContent = '0';
  timeBendCounter.textContent = gameState.timeBend.currentUses;
  gameOverScreen.style.display = 'none';
  gameOverScreen.style.opacity = '0';
  
  // Properly reset the cooldown animation
  timeBendCooldown.style.animation = '';
  timeBendCooldown.offsetHeight; // Force reflow
  timeBendCooldown.style.animation = 'none';
}

    function setupEventListeners() {
      let isTouching = false;
      const handleMove = (clientX) => {
        if (!isTouching || !gameState.gameActive) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const touchX = (clientX - rect.left) * scaleX;
        gameState.player.targetX = touchX;
      };
      canvas.addEventListener('touchstart', (e) => { e.preventDefault(); isTouching = true; handleMove(e.touches[0].clientX); });
      canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e.touches[0].clientX); });
      canvas.addEventListener('touchend', (e) => { e.preventDefault(); isTouching = false; });
      timeBendBtn.addEventListener('click', activateTimeBend);
      safeModeBtn.addEventListener('click', () => startGame('safe'));
      fractureModeBtn.addEventListener('click', () => startGame('fracture'));
      shopBtn.addEventListener('click', showShop);
      leaderboardBtn.addEventListener('click', showLeaderboard);
      dailyCheckInBtn.addEventListener('click', showDailyCheckIn);
      referralBtn.addEventListener('click', showReferral);
      retryBtn.addEventListener('click', () => startGame(gameState.mode));
      fractureRetryBtn.addEventListener('click', () => startGame('fracture'));
      menuBtn.addEventListener('click', () => showMenu());
      backToMenuBtn.addEventListener('click', () => showMenu());
      leaderboardBackBtn.addEventListener('click', () => showMenu());
      upgradeTimeBendBtn.addEventListener('click', purchaseTimeBend);
      upgradeMagnetBtn.addEventListener('click', purchaseMagnet);
      buyRelicBtn.addEventListener('click', purchasePhantomRelic);
			
			// Add mouse controls for desktop
canvas.addEventListener('mousedown', (e) => {
  e.preventDefault();
  isTouching = true;
  handleMove(e.clientX);
});

canvas.addEventListener('mousemove', (e) => {
  if (!isTouching) return;
  e.preventDefault();
  handleMove(e.clientX);
});

canvas.addEventListener('mouseup', (e) => {
  e.preventDefault();
  isTouching = false;
});

canvas.addEventListener('mouseleave', (e) => {
  e.preventDefault();
  isTouching = false;
});
      
      // Leaderboard tabs
      leaderboardTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          leaderboardTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          updateLeaderboard(tab.dataset.type);
        });
      });
    }

// Add class to body when game is active for styling
function startGame(mode) {
  if (!currentUser) {
    showAuthScreen();
    return;
  }
  
  document.body.classList.add('game-active');
      
      gameState.mode = mode;
      resetGameState();
      menuScreen.style.display = 'none';
      shopScreen.style.display = 'none';
      leaderboardScreen.style.display = 'none';
      authScreen.style.display = 'none';
      profileScreen.style.display = 'none';
      dailyCheckInScreen.style.display = 'none';
      referralScreen.style.display = 'none';
    }

    function showMenu() {
  document.body.classList.remove('game-active');
      menuScreen.style.display = 'flex';
      shopScreen.style.display = 'none';
      gameOverScreen.style.display = 'none';
      leaderboardScreen.style.display = 'none';
      authScreen.style.display = 'none';
      profileScreen.style.display = 'none';
      dailyCheckInScreen.style.display = 'none';
      referralScreen.style.display = 'none';
      gameState.gameActive = false;
    }

    function showShop() {
      if (!currentUser) {
        showAuthScreen();
        return;
      }
      
      menuScreen.style.display = 'none';
      shopScreen.style.display = 'flex';
      leaderboardScreen.style.display = 'none';
      authScreen.style.display = 'none';
      profileScreen.style.display = 'none';
      dailyCheckInScreen.style.display = 'none';
      referralScreen.style.display = 'none';
      updateShopUI();
    }
    
    function showLeaderboard() {
  if (!currentUser) {
    showAuthScreen();
    return;
  }
  
  menuScreen.style.display = 'none';
  shopScreen.style.display = 'none';
  leaderboardScreen.style.display = 'flex';
  authScreen.style.display = 'none';
  profileScreen.style.display = 'none';
  dailyCheckInScreen.style.display = 'none';
  referralScreen.style.display = 'none';
  
  // Force fresh data load with timestamp to avoid caching
  setTimeout(() => {
    updateLeaderboard('score');
  }, 100);
}
    
    function showReferral() {
      if (!currentUser) {
        showAuthScreen();
        return;
      }
      
      menuScreen.style.display = 'none';
      shopScreen.style.display = 'none';
      leaderboardScreen.style.display = 'none';
      authScreen.style.display = 'none';
      profileScreen.style.display = 'none';
      dailyCheckInScreen.style.display = 'none';
      referralScreen.style.display = 'flex';
      updateReferralUI();
    }
    
    function showProfileScreen() {
      if (!currentUser) {
        showAuthScreen();
        return;
      }
      
      menuScreen.style.display = 'none';
      shopScreen.style.display = 'none';
      leaderboardScreen.style.display = 'none';
      authScreen.style.display = 'none';
      profileScreen.style.display = 'flex';
      dailyCheckInScreen.style.display = 'none';
      referralScreen.style.display = 'none';
      updateUserProfile();
    }
    
    function showAuthScreen() {
      menuScreen.style.display = 'none';
      shopScreen.style.display = 'none';
      leaderboardScreen.style.display = 'none';
      authScreen.style.display = 'flex';
      profileScreen.style.display = 'none';
      dailyCheckInScreen.style.display = 'none';
      referralScreen.style.display = 'none';
      updateAuthUI();
      
      // Clear input fields
      emailInput.value = '';
      passwordInput.value = '';
      usernameSignUpInput.value = '';
      signUpEmailInput.value = '';
      signUpPasswordInput.value = '';
      confirmPasswordInput.value = '';
      
      // Hide error messages
      authError.style.display = 'none';
      signUpError.style.display = 'none';
    }
    
    function getUpgradeCost(baseCost, level) {
        return Math.floor(baseCost * Math.pow(1.5, level));
    }

    function updateShopUI() {
        totalShardsEl.textContent = gameState.totalShards;
        
        // Time Bend
        const timeBendLevel = gameState.upgrades.timeBendLevel;
        const timeBendCost = getUpgradeCost(50, timeBendLevel - 1);
        timeBendLevelEl.textContent = timeBendLevel;
        timeBendCostEl.textContent = `${timeBendCost} ✦`;
        upgradeTimeBendBtn.disabled = gameState.totalShards < timeBendCost;
        
        // Shard Magnet
        const magnetLevel = gameState.upgrades.shardMagnetLevel;
        const magnetCost = getUpgradeCost(30, magnetLevel);
        magnetLevelEl.textContent = magnetLevel;
        magnetCostEl.textContent = `${magnetCost} ✦`;
        upgradeMagnetBtn.disabled = gameState.totalShards < magnetCost;
        
        // Phantom Relic
        const phantomLevel = gameState.upgrades.phantomPhaseLevel;
        const phantomCost = getUpgradeCost(120, phantomLevel);
        phantomLevelEl.textContent = phantomLevel;
        phantomCostEl.textContent = `${phantomCost} ✦`;
        buyRelicBtn.disabled = gameState.totalShards < phantomCost;
        buyRelicBtn.textContent = phantomLevel > 0 ? "Upgrade" : "Purchase";
    }

    function purchaseTimeBend() {
        const level = gameState.upgrades.timeBendLevel;
        const cost = getUpgradeCost(50, level - 1);
        if (gameState.totalShards >= cost) {
            gameState.totalShards -= cost;
            gameState.upgrades.timeBendLevel++;
            updateShopUI();
            
            if (currentUser) {
                saveUserData();
            }
        }
    }

    function purchaseMagnet() {
        const level = gameState.upgrades.shardMagnetLevel;
        const cost = getUpgradeCost(30, level);
        if (gameState.totalShards >= cost) {
            gameState.totalShards -= cost;
            gameState.upgrades.shardMagnetLevel++;
            updateShopUI();
            
            if (currentUser) {
                saveUserData();
            }
        }
    }

    function purchasePhantomRelic() {
        const level = gameState.upgrades.phantomPhaseLevel;
        const cost = getUpgradeCost(120, level);
        if (gameState.totalShards >= cost) {
            gameState.totalShards -= cost;
            gameState.upgrades.phantomPhaseLevel++;
            gameState.relics.phantomPhase = true;
            updateShopUI();
            
            if (currentUser) {
                saveUserData();
            }
        }
    }

    function endGame() {
  document.body.classList.remove('game-active');
        if (!gameState.player.isAlive) return;
        gameState.gameActive = false;
        gameState.player.isAlive = false;
        createParticleExplosion(gameState.player.x, gameState.player.y, 40, '#00f3ff');
        
        setTimeout(() => {
            const time = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            timeSurvived.textContent = `${Math.floor(time/60)}:${(time%60).toString().padStart(2, '0')}`;
            //-- REPLACEMENT --//
const finalScoreInSeconds = (gameState.score / 1000).toFixed(3);
finalScore.textContent = formatScore(gameState.score);
            shardsCollected.textContent = gameState.currentRunShards;
            
            // Update totals
            gameState.totalShards += gameState.currentRunShards;
            
            // Update high score if needed
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
            }
            
            // Save game data if user is logged in
            if (currentUser) {
                saveUserData();
            }
            
            gameOverScreen.style.display = 'flex';
            setTimeout(() => gameOverScreen.style.opacity = '1', 50);
        }, 800);
    }
    
    function activateTimeBend() {
      if (gameState.timeBend.currentUses > 0 && !gameState.timeBend.active && gameState.timeBend.cooldown <= 0) {
        gameState.timeBend.currentUses--;
        gameState.timeBend.active = true;
        gameState.timeBend.cooldown = gameState.timeBend.maxCooldown;
        
        // Update counter display
        timeBendCounter.textContent = gameState.timeBend.currentUses;
        
        // Show time bend effect
        timeBendEffect.style.opacity = '1';
        
        setTimeout(() => { 
          gameState.timeBend.active = false;
          timeBendEffect.style.opacity = '0';
        }, gameState.timeBend.duration);
        
        timeBendCooldown.style.animation = `cooldown ${gameState.timeBend.maxCooldown/1000}s linear forwards`;
        setTimeout(() => { timeBendCooldown.style.animation = ''; }, gameState.timeBend.maxCooldown);
      }
    }
    
    function createParticleExplosion(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 4;
            gameState.particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, alpha: 1, size: 1 + Math.random() * 3, color: color });
        }
    }

    // [FIXED] Game logic updated for time-based scoring and speed
    function updateGame() {
    if (!gameState.gameActive) return;

    const currentTime = Date.now();
    const timeFactor = gameState.timeBend.active ? 0.4 : 1.0;

    // Calculate elapsed time in seconds for consistent speed scaling
    const elapsedSecondsForSpeed = (currentTime - gameState.gameStartTime) / 1000;
    
    // Update speed multiplier based on time, not score (0.1% increase per second)
    gameState.speedMultiplier = 1.0 + (elapsedSecondsForSpeed * 0.001);

    // Update score based on elapsed milliseconds for fairness
    gameState.score = currentTime - gameState.gameStartTime;
    const scoreInSeconds = (gameState.score / 1000).toFixed(3);
    scoreValue.textContent = formatScore(gameState.score);

    const isFracture = gameState.mode === 'fracture';
    const basePathSpeed = isFracture ? 4 : 2;
    const pathSpeed = basePathSpeed * gameState.speedMultiplier;

    // Update Player
    gameState.player.x += (gameState.player.targetX - gameState.player.x) * 0.15;
    gameState.player.x = Math.max(PLAYER_SIZE / 2, Math.min(GAME_WIDTH - PLAYER_SIZE / 2, gameState.player.x));

    gameState.player.trail.push({ x: gameState.player.x, y: gameState.player.y, alpha: 1 });
    if (gameState.player.trail.length > 20) gameState.player.trail.shift();
    gameState.player.trail.forEach(p => p.alpha -= 0.05);

    // Update Game World
    gameState.path.nextY -= pathSpeed * timeFactor;
    if (gameState.path.nextY <= 0) {
        createObstacleLayer(-30);
        const baseDistance = isFracture ? 80 : 120;
        gameState.path.nextY = baseDistance + Math.random() * 40;
    }

    const shardSpawnRate = isFracture ? 0.03 : 0.015;
    if (Math.random() < shardSpawnRate * timeFactor) createShard();

    // Update Obstacles
    gameState.obstacles.forEach((obs, i) => {
        obs.y += (obs.speed * gameState.speedMultiplier + elapsedSecondsForSpeed * 0.005) * timeFactor;
        if (obs.y > GAME_HEIGHT + 30) gameState.obstacles.splice(i, 1);
    });

    // Update Shards
    gameState.shardsCollectible.forEach((shard, i) => {
        shard.y += (isFracture ? 3 : 2) * gameState.speedMultiplier * timeFactor;
        const dx = shard.x - gameState.player.x;
        const dy = shard.y - gameState.player.y;
        const magnetRadius = 15 + (gameState.upgrades.shardMagnetLevel * 15);
        if (Math.sqrt(dx * dx + dy * dy) < PLAYER_SIZE / 2 + magnetRadius) {
            gameState.currentRunShards++;
            shardValue.textContent = gameState.currentRunShards;
            createParticleExplosion(shard.x, shard.y, 10, '#f300ff');
            gameState.shardsCollectible.splice(i, 1);
        } else if (shard.y > GAME_HEIGHT + 20) {
            gameState.shardsCollectible.splice(i, 1);
        }
    });

    checkCollisions();
}
    
    function checkCollisions() {
  if (!gameState.player.isAlive) return;
  const hitboxWidth = PLAYER_SIZE * 0.5;
  const hitboxHeight = PLAYER_SIZE * 0.9;
  const pL = gameState.player.x - hitboxWidth / 2;
  const pR = gameState.player.x + hitboxWidth / 2;
  const pT = gameState.player.y - hitboxHeight / 2;
  const pB = gameState.player.y + hitboxHeight / 2;

  for (const obs of gameState.obstacles) {
    const oL = obs.x;
    const oR = obs.x + obs.width;
    const oT = obs.y;
    const oB = obs.y + obs.height;

    if (pR > oL && pL < oR && pB > oT && pT < oB) {
      // THIS IS WHERE THE CODE GOES - IT'S ALREADY THERE:
      if (gameState.relics.phantomPhase && gameState.relics.phantomPhaseUsed < gameState.upgrades.phantomPhaseLevel) {
        gameState.relics.phantomPhaseUsed++;
        createParticleExplosion(obs.x + obs.width/2, obs.y + obs.height/2, 30, '#ffffff');
        const obsIndex = gameState.obstacles.indexOf(obs);
        if (obsIndex > -1) {
          gameState.obstacles.splice(obsIndex, 1);
        }
        return;
      } else {
        endGame();
        return;
      }
    }
  }
}
    
    function drawPlayerCharacter(ctx, x, y, size, time) {
        ctx.save();
        ctx.translate(x, y);
        const tilt = (gameState.player.targetX - x) * 0.005;
        ctx.rotate(tilt);
        const breath = Math.sin(time * 5) * 0.05 + 1;
        if (gameState.timeBend.active) {
            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2.5);
            grad.addColorStop(0, 'rgba(0, 243, 255, 0.4)');
            grad.addColorStop(1, 'rgba(0, 243, 255, 0)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, size * 2.5, 0, Math.PI * 2); ctx.fill();
        }
        ctx.beginPath();
        ctx.moveTo(0, -size * 0.8 * breath);
        ctx.bezierCurveTo(size * 0.7, -size * 0.4, size * 0.6, size * 0.6, 0, size * breath);
        ctx.bezierCurveTo(-size * 0.6, size * 0.6, -size * 0.7, -size * 0.4, 0, -size * 0.8 * breath);
        ctx.closePath();
        const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
        bodyGrad.addColorStop(0, 'white');
        bodyGrad.addColorStop(0.4, '#00f3ff');
        bodyGrad.addColorStop(1, '#f300ff');
        ctx.fillStyle = bodyGrad;
        ctx.shadowColor = '#00f3ff';
        ctx.shadowBlur = 25;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(0, -size * 0.3, size * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.shadowColor = 'white';
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.restore();
    }

    function drawPlayerTrail(ctx) {
        gameState.player.trail.forEach((p, i) => {
            ctx.beginPath();
            const alpha = p.alpha * (i / gameState.player.trail.length);
            ctx.fillStyle = `rgba(0, 243, 255, ${alpha * 0.5})`;
            ctx.arc(p.x, p.y + 10, i / 4, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function drawGame() {
      ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
      if (gameState.player.isAlive) {
          drawPlayerTrail(ctx);
          drawPlayerCharacter(ctx, gameState.player.x, gameState.player.y, gameState.player.size, Date.now() / 1000);
      }
      gameState.obstacles.forEach(obs => {
        const color = obs.isFracture ? '#00a2ff' : '#ff007a';
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 15;
        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
      });
      gameState.shardsCollectible.forEach(shard => {
        ctx.fillStyle = '#f300ff';
        ctx.shadowColor = '#f300ff';
        ctx.shadowBlur = 15;
        ctx.beginPath(); ctx.arc(shard.x, shard.y, 10, 0, Math.PI * 2); ctx.fill();
      });
      // Draw and update particles with proper cleanup
for (let i = gameState.particles.length - 1; i >= 0; i--) {
  const p = gameState.particles[i];
  p.alpha -= 0.02;
  if (p.alpha <= 0) {
    gameState.particles.splice(i, 1);
    continue;
  }
  p.x += p.vx;
  p.y += p.vy;
  ctx.fillStyle = `${p.color}${Math.floor(p.alpha * 255).toString(16).padStart(2, '0')}`;
  ctx.beginPath();
  ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
  ctx.fill();
}

// Limit particle array size to prevent memory issues
if (gameState.particles.length > 200) {
  gameState.particles = gameState.particles.slice(-150);
}

ctx.shadowBlur = 0;
} // ← ADD THIS CLOSING BRACE FOR drawGame()
    
function createObstacleLayer(baseY) {
        const isFracture = gameState.mode === 'fracture';
        const speed = isFracture ? 4 : 2;
        const obsDefaults = { y: baseY, height: 20, speed: speed, passed: true, isFracture: isFracture };
        
        const gapSize = PLAYER_SIZE + (isFracture ? 60 : 75);
        const maxDrift = 120;

        let nextPathX = gameState.path.lastX + (Math.random() - 0.5) * maxDrift;
        nextPathX = Math.max(gapSize / 2, Math.min(GAME_WIDTH - gapSize / 2, nextPathX));
        gameState.path.lastX = nextPathX;

        const gapStart = nextPathX - gapSize / 2;
        const gapEnd = nextPathX + gapSize / 2;
        
        const density = isFracture ? 0.9 : 0.7;

        for (let i = 0; i < (isFracture ? 12 : 8); i++) {
            const fragX = Math.random() * GAME_WIDTH;
            const fragWidth = 20 + Math.random() * 50;

            if (fragX + fragWidth > gapStart && fragX < gapEnd) {
                continue;
            }

            if (Math.random() < density) {
                 gameState.obstacles.push({
                    ...obsDefaults,
                    x: fragX,
                    width: fragWidth,
                    y: baseY + (Math.random() * 40 - 20)
                });
            }
        }
    }

    function createShard() {
      gameState.shardsCollectible.push({ x: Math.random() * (GAME_WIDTH - 20) + 10, y: -15 });
    }
    
    function gameLoop() {
      if (gameState.gameActive) {
          updateGame();
      }
      drawGame();
      requestAnimationFrame(gameLoop);
    }
    
    window.addEventListener('load', initGame);
		// Prevent right-click context menu
document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  return false;
});

// Prevent text selection with mouse
document.addEventListener('selectstart', (e) => {
  e.preventDefault();
  return false;
});

// Prevent drag
document.addEventListener('dragstart', (e) => {
  e.preventDefault();
  return false;
});

// Prevent keyboard shortcuts for copying
document.addEventListener('keydown', (e) => {
  // Prevent Ctrl+A, Ctrl+C, Ctrl+X, Ctrl+S
  if (e.ctrlKey && (e.keyCode === 65 || e.keyCode === 67 || e.keyCode === 88 || e.keyCode === 83)) {
    e.preventDefault();
    return false;
  }
  // Prevent F12 (Developer Tools)
  if (e.keyCode === 123) {
    e.preventDefault();
    return false;
  }
});
  </script>
</body>
</html>